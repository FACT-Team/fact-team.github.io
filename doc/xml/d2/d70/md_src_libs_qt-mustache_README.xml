<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.9.1">
  <compounddef id="d2/d70/md_src_libs_qt-mustache_README" kind="page">
    <compoundname>md_src_libs_qt-mustache_README</compoundname>
    <title>README</title>
    <detaileddescription>
<para><ulink url="https://travis-ci.org/robertknight/qt-mustache">![Build Status](https://travis-ci.org/robertknight/qt-mustache.svg?branch=master)</ulink></para><para><heading level="1">Qt Mustache</heading>
</para><para>qt-mustache is a simple library for rendering <ulink url="http://mustache.github.com/">Mustache templates</ulink>.</para><para><heading level="3">Example Usage</heading>
</para><para>```cpp #include &quot;mustache.h&quot;</para><para>QVariantHash contact; contact[&quot;name&quot;] = &quot;John Smith&quot;; contact[&quot;email&quot;] = &quot;john.smith@gmail.com&quot;;</para><para>QString contactTemplate = &quot;&lt;b&gt;{{name}}&lt;/b&gt; &lt;a href=\&quot;mailto:{{email}}"&gt;{{email}}";</para><para><ref refid="dc/d58/classMustache_1_1Renderer" kindref="compound">Mustache::Renderer</ref> renderer; <ref refid="d5/d8b/classMustache_1_1QtVariantContext" kindref="compound">Mustache::QtVariantContext</ref> context(contact);</para><para>QTextStream output(stdout); output &lt;&lt; renderer.render(contactTemplate, &amp;context); ```</para><para>Outputs: <computeroutput>&lt;b&gt;John Smith&lt;/b&gt; &lt;a href=&quot;mailto:john.smith\@gmail.com&quot;&gt;john.smith@gmail.com&lt;/a&gt;</computeroutput></para><para>For further examples, see the tests in <computeroutput>test_mustache.cpp</computeroutput></para><para><heading level="3">Building</heading>
</para><para><itemizedlist>
<listitem><para>To build the tests, run <computeroutput>qmake</computeroutput> followed by <computeroutput>make</computeroutput></para></listitem><listitem><para>To use qt-mustache in your project, just add the <computeroutput><ref refid="d9/d77/mustache_8h_source" kindref="compound">mustache.h</ref></computeroutput> and <computeroutput>mustache.cpp</computeroutput> files to your project.</para></listitem></itemizedlist>
</para><para><heading level="3">License</heading>
</para><para>qt-mustache is licensed under the BSD license.</para><para><heading level="3">Dependencies</heading>
</para><para>qt-mustache depends on the QtCore library. It is compatible with Qt 4 and Qt 5.</para><para><heading level="2">Usage</heading>
</para><para><heading level="3">Syntax</heading>
</para><para>qt-mustache uses the standard Mustache syntax. See the <ulink url="http://mustache.github.com/mustache.5.html">Mustache manual</ulink> for details.</para><para><heading level="3">Data Sources</heading>
</para><para>qt-mustache expands Mustache tags using values from a <computeroutput><ref refid="d7/d34/classMustache_1_1Context" kindref="compound">Mustache::Context</ref></computeroutput>. <computeroutput><ref refid="d5/d8b/classMustache_1_1QtVariantContext" kindref="compound">Mustache::QtVariantContext</ref></computeroutput> is a simple context implementation which wraps a <computeroutput>QVariantHash</computeroutput> or <computeroutput>QVariantMap</computeroutput>. If you want to render a template using a custom data source, you can either create a <computeroutput>QVariantHash</computeroutput> which mirrors the data source or you can re-implement <computeroutput><ref refid="d7/d34/classMustache_1_1Context" kindref="compound">Mustache::Context</ref></computeroutput>.</para><para><heading level="3">Partials</heading>
</para><para>When a <computeroutput>{{&gt;partial}}</computeroutput> Mustache tag is encountered, qt-mustache will attempt to load the partial using a <computeroutput><ref refid="d0/dce/classMustache_1_1PartialResolver" kindref="compound">Mustache::PartialResolver</ref></computeroutput> provided by the context. <computeroutput><ref refid="dc/d1a/classMustache_1_1PartialMap" kindref="compound">Mustache::PartialMap</ref></computeroutput> is a simple resolver which takes a <computeroutput>QHash&lt;QString,QString&gt;</computeroutput> map of partial names to values and looks up partials in that map. <computeroutput><ref refid="da/d31/classMustache_1_1PartialFileLoader" kindref="compound">Mustache::PartialFileLoader</ref></computeroutput> is another simple resolver which fetches partials from <computeroutput>&lt;partial name&gt;.mustache</computeroutput> files in a specified directory.</para><para>You can re-implement the <computeroutput><ref refid="d0/dce/classMustache_1_1PartialResolver" kindref="compound">Mustache::PartialResolver</ref></computeroutput> interface if you want to load partials from a custom source (eg. a database).</para><para><heading level="3">Error Handling</heading>
</para><para>If an error occurs when rendering a template, <computeroutput>Mustache::Renderer::errorPosition()</computeroutput> is set to non-negative value and template rendering stops. If the error occurs whilst rendering a partial template, <computeroutput>errorPartial()</computeroutput> contains the name of the partial.</para><para><heading level="3">Lambdas</heading>
</para><para>The <ulink url="http://mustache.github.com/mustache.5.html">Mustache manual</ulink> provides a mechanism to customize rendering of template sections by setting the value for a tag to a callable object (eg. a lambda in Ruby or Javascript), which takes the unrendered block of text for a template section and renders it itself. qt-mustache supports this via the <computeroutput>Context::canEval()</computeroutput> and <computeroutput>Context::eval()</computeroutput> methods. </para>    </detaileddescription>
  </compounddef>
</doxygen>
